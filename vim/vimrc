" ----------------------------------------------------------------------------
"  $Id$
"
"  Vim configuration file
" ----------------------------------------------------------------------------

" ----------------------------------------------------------------------------
" Use Vim rather than Vi settings (much better!)
" This must be first, because it changes other options as a side effect
"
set nocompatible

" ----------------------------------------------------------------------------
" When started as "evim", evim.vim will already have done these settings
"
if v:progname =~? "evim"
        finish
endif

" ----------------------------------------------------------------------------
"  Plugins config section (using Vundle)
"
filetype off
set rtp+=~/.vim/bundles/vundle/
call vundle#rc("~/.vim/bundles")

call vundle#begin()

" Required {
        Plugin 'gmarik/vundle'
" }

Plugin 'https://github.com/chriskempson/base16-vim'

Plugin 'https://github.com/tpope/vim-tbone.git'

Plugin 'https://github.com/sk1418/QFGrep'

Plugin 'https://github.com/AndrewRadev/linediff.vim.git'

Plugin 'https://github.com/chrisbra/csv.vim'

" vim-notes {
        Plugin 'https://github.com/xolox/vim-misc.git'
        Plugin 'https://github.com/xolox/vim-notes.git'
" }

Plugin 'https://github.com/godlygeek/tabular.git'

Plugin 'https://github.com/LaTeX-Box-Team/LaTeX-Box'

Plugin 'VisIncr'

Plugin 'https://github.com/ervandew/supertab.git'

Plugin 'https://github.com/kien/ctrlp.vim'

Plugin 'https://github.com/christoomey/vim-tmux-navigator'

Plugin 'https://github.com/molok/vim-smartusline'

call vundle#end()

" ----------------------------------------------------------------------------
" Enable extended % matching
"
runtime macros/matchit.vim

" ----------------------------------------------------------------------------
" Enable file type detection. Use the default filetype settings, so that mail
" gets 'tw' set to 72, 'cindent' is on in C files, etc. Also load indent
" files, to automatically do language-dependent indenting.
"
"filetype plugin indent on
filetype plugin on

" ----------------------------------------------------------------------------
" Automatically reload config file when it is written
"
autocmd! BufWritePost .vimrc source %
autocmd! BufWritePost ~/.vim/vimrc source %

" ----------------------------------------------------------------------------
" Switch syntax highlighting on, when the terminal has colors
"
if &t_Co > 2 || has("gui_running")
        syntax on
endif

" ----------------------------------------------------------------------------
" General settings
"
" Automatically read again a file when changed outside of Vim
set autoread

" Allow backspacing over everything in insert mode
set backspace=indent,eol,start

" Number of screen lines to use for the command-line window
set cmdwinheight=5

" Character encoding
set encoding=utf-8

" Make a buffer hidden when it is |abandon|ed (instead of unloading it)
set hidden

" Keep 100 lines of command line history
set history=100

" Do not redraw the screen while executing commands that have not been typed
set lazyredraw

" "Leader" key mapping
"let mapleader="\<Space>"
"let maplocalleader="\<Space>"
let mapleader="!"
let maplocalleader="!"

" Enable mouse use in all modes (in console too)
set mouse=a

" Disable beeping (aka bell) and window flashing
set noerrorbells visualbell t_vb=

" Switch off automatically setting options by means of modelines (to prevent
" some security exploits)
set nomodeline

" Command for starting a shell
set shell=/bin/sh

" The time in milliseconds that is waited for a mapped key
set timeoutlen=500

" Do not set xterm title
"set notitle

" The time in milliseconds that is waited for a key code
set ttimeoutlen=10

" Improves smoothness of redrawing
set ttyfast

" On pressing 'wildchar' (usually <Tab>) to invoke completion, the possible
" matches are shown
set wildmenu

" When more than one match, complete till longest common string
set wildmode=longest,list

" ----------------------------------------------------------------------------
" Tabs and indentation
"
" Copy indent from current line when starting a new line
set autoindent

" Do smart autoindenting when starting a new line
set smartindent

" Use spaces instead of tabs by default
set expandtab

" Number of spaces that a <Tab> in the file counts for
set tabstop=8

" Number of spaces to use for each step of (auto)indent
set shiftwidth=8

" Number of spaces that a <Tab> counts for while performing editing operations
set softtabstop=8

" ----------------------------------------------------------------------------
" Search
"
" Highlight the last used search pattern
set hlsearch
nnoremap <silent> <Tab> :nohlsearch<CR>

" Highlight all occurrences of the word under the cursor (without moving)
nnoremap <Leader>* :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>

" Searching is not case sensitive
set ignorecase

" While typing a search command, show where the pattern matches
set incsearch

" If a pattern contains an uppercase letter, it is case sensitive, otherwise, it is not
set smartcase

" ----------------------------------------------------------------------------
" Visibility and context
"
" Highlight the screen line of the cursor
if exists("$DISPLAY")
        set cursorline
endif

" Precede each line with its line number
set number

" Show the line number relative to the line with the cursor
if exists("+relativenumber")
        set norelativenumber
        nnoremap <silent> <leader>R :set relativenumber!<CR>
endif
nnoremap <silent> <leader>N :set number!<CR>

" Minimal number of screen lines to keep above and below the cursor
nnoremap <silent> <leader>S :let &scrolloff=5-&scrolloff<CR>

" Show the cursor position all the time
set noruler

" Minimal number of screen lines to keep above and below the cursor
set scrolloff=2

" Wrap long lines
set nowrap

" ----------------------------------------------------------------------------
" Windows and tabs
"
" Splitting a window will put the new window below/right the current one
set splitbelow
set splitright

" Never show tab page labels
set showtabline=0

" ----------------------------------------------------------------------------
" Undo
"
if exists("+undofile")
        " Store undo info so you can undo previous actions even after you close and reopen a file (only in 7.3)
        set undofile
        " Store undo files in a fixed location, not current directory
        set undodir=~/.vim/undo
endif

" ----------------------------------------------------------------------------
" Unprintable chars highlighting
"
set list
nnoremap <silent> <leader>0 :set list!<CR>

if (&term != "vt220") && (&term != "wsvt25")
        set listchars=tab:→\ ,trail:·,extends:»,precedes:«,nbsp:·
else
        set listchars=tab:>\ ,trail:.,extends:>,precedes:<,nbsp:.
endif

" ----------------------------------------------------------------------------
" Status line
"
" Display incomplete commands
set showcmd

" If in Insert, Replace or Visual mode put a message on the last line
set showmode

" Always show a status line for the last window
set laststatus=2

" Paste status
function! PasteStatus()
        if (&paste)
                return '[paste] '
        else
                return ''
        endif
endfunction

" Working with multiple tabs (considered unusual...)
function! MultiTabs()
        if (tabpagewinnr(2, '$') > 0)
                return '[tab+] '
        else
                return ''
        endif
endfunction

set statusline=%*                               " Reset statusline format
set statusline+=[%t]\                           " Name (tail) of file in the buffer
set statusline+=[#%n]\                          " Buffer number
set statusline+=[%Y%W%R%M%W]\                   " Filetype
set statusline+=%{'['.&ff.']'}\                 " File format
set statusline+=%{'['.&fenc.']'}\               " File encoding
set statusline+=%{MultiTabs()}                  " Working with multiple tab pages
set statusline+=%{PasteStatus()}                " Paste mode
set statusline+=%=                              " Move to right
set statusline+=[0x%B]\                         " Current char
set statusline+=[%l/%L\ %c]\                    " Cursor line / total lines
set statusline+=%P                              " Percent through file

" ----------------------------------------------------------------------------
" Store swap files in fixed location, not current directory
" (swap file name will be built from the complete path to
" the file with all path separators substituted to percent '%' signs)
"
set dir=~/.vim/swap//,/var/tmp//,/tmp//,.

" ----------------------------------------------------------------------------
" Insert/command mode flag
"
if exists("$DISPLAY")
        au InsertEnter * setlocal cursorcolumn
        if exists("+colorcolumn")
                au InsertEnter * setlocal colorcolumn=78
        endif

        au InsertLeave * setlocal nocursorcolumn
        if exists("+colorcolumn")
                au InsertLeave * setlocal colorcolumn=0
        endif
endif

" ----------------------------------------------------------------------------
" Colorscheme
"
if exists("$DISPLAY")
        set t_Co=256
        if filereadable(expand("$HOME/.vim/colors/base16.vim"))
                colorscheme base16
        endif
endif

function! MinimalSyntaxSwap()
        if ! exists("b:minSyntax") || b:minSyntax == 0
                let b:minSyntax = 1
                hi Boolean term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Character term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Conceal term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Conditional term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Constant term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Debug term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Define term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Delimiter term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Directive term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Exception term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Float term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Format term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Function term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Identifier term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Ignore term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Include term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Keyword term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Label term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Macro term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Number term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Operator term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi PreCondit term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi PreProc term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Repeat term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi SpecialChar term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi SpecialComment term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Special term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Statement term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi StorageClass term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi String term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Structure term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Tag term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Title term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Typedef term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Type term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
                hi Underlined term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE
        else
                let b:minSyntax = 0
                if exists("$DISPLAY")
                        set t_Co=256
                        if filereadable(expand("$HOME/.vim/colors/base16.vim"))
                                colorscheme base16
                        else
                                colorscheme default
                        endif
                else
                        colorscheme default
                endif
        endif
endfunction

if exists("$DISPLAY")
        let b:minSyntax = 0
else
        call MinimalSyntaxSwap()
endif

nnoremap <silent> <leader>sx :call MinimalSyntaxSwap()<CR>

" ----------------------------------------------------------------------------
" Don't use Ex mode, use Q for formatting
"
map Q gq

" ----------------------------------------------------------------------------
" Put these in an autocmd group, so that we can delete them easily.
"
augroup vimrcEx
au!

" For all text files set 'textwidth' to 78 characters.
autocmd FileType text setlocal textwidth=78

augroup END

" ----------------------------------------------------------------------------
" Force the cursor to drop back ONLY when necessary when
" exiting insert mode
"
"inoremap <silent> <Esc> <C-O>:stopinsert<CR>

" ----------------------------------------------------------------------------
" Turn on English/Italian spell checking
"
nnoremap <silent> <leader>E :setlocal spell spelllang=en<CR>
        \:echo "Spell check (EN) switched on"<CR>
nnoremap <silent> <leader>I :setlocal spell spelllang=it<CR>
        \:echo "Spell check (IT) switched on"<CR>
nnoremap <silent> <leader>so :setlocal nospell<CR>
        \:echo "Spell check switched off"<CR>

" ----------------------------------------------------------------------------
" Make jumping to a marked line more intuitive
"
nnoremap ` '
nnoremap ' `

" ----------------------------------------------------------------------------
" Occur: report all the lines containing a keyword (or the last search
" regexp) in a scratch buffer
"
" Note: External grep doesn't work when filenames contain unusual
"       characters (e.g., ":")
"set grepprg=egrep\ -n\ -i\ $*\ /dev/null
"        \ execute 'silent grep! <args>' |
command! -nargs=+ Occur
        \ execute 'silent vimgrep! <args>' |
        \ copen 20 |
        \ redraw!
nnoremap <silent> <leader>w :Occur /warn/ %<CR>
nnoremap <silent> <leader>e :Occur /error/ %<CR>

" ----------------------------------------------------------------------------
" Delete all lines containing the WORD under the cursor
"
nnoremap <silent> <leader>dw
        \ :let cl=line(".")<CR>:g/<C-R><C-A>/d<CR>:call cursor(cl, 1)<CR>

" ----------------------------------------------------------------------------
" Paste the visual selection to the scratchpad (along with
" the current file name)
"
vnoremap <silent> <leader>ps
        \ :<C-U>silent! '<,'>w >> ~/.scratchpad<CR>
        \ :call system("echo Yanked from: " . shellescape(expand("%:p")) . " >> ~/.scratchpad")<CR>

" ----------------------------------------------------------------------------
" Copy the current buffer filename (with full path)
"
nnoremap <silent> <leader>yy :let @*=expand("%:p")<CR>

" ----------------------------------------------------------------------------
" Search for visual selection
"
vnoremap * <Esc>/<C-R>*<CR>
vnoremap # <Esc>?<C-R>*<CR>

" ----------------------------------------------------------------------------
" Swap wrap mode
"
nnoremap <silent> <leader>W :set wrap!<CR>

" ----------------------------------------------------------------------------
" Toggle cursorline/cursorcolumn mode
"
nnoremap <silent> <C-_> :set cursorline!<CR>
function! CursorColumnVisibilityToggling()
        if (&cursorcolumn)
                setlocal nocursorcolumn
                setlocal colorcolumn=0
        else
                setlocal cursorcolumn
                setlocal colorcolumn=78
        endif
endfunction
nnoremap <silent> <C-\> :call CursorColumnVisibilityToggling()<CR>

" ----------------------------------------------------------------------------
" Always go to the beginning of a line before doing a 'gF' operation
"
nnoremap gF 0gF

" ----------------------------------------------------------------------------
" Always use command window when enter command mode
"
"nnoremap : q:i

" ----------------------------------------------------------------------------
" Fix default regex handling (this makes searches use EREs)
"
"nnoremap / /\v
"vnoremap / /\v
"nnoremap <leader>/ /\V
"vnoremap <leader>/ /\V
"nnoremap ? ?\v
"vnoremap ? ?\v
"nnoremap <leader>? ?\V
"vnoremap <leader>? ?\V

" ----------------------------------------------------------------------------
" Quickly close current buffer
"
nnoremap <silent> <leader>q :bdelete<CR>

" ----------------------------------------------------------------------------
" Mappings to access buffers (don't use "\p" because a delay before
" pressing "p" would accidentally paste).
" \ls      : list buffers
" \b \f \g : go back/forward/last-used
" \1 \2 \3 : go to buffer 1/2/3 etc.
"
nnoremap <leader>l  :ls<CR>
nnoremap <leader>b  :bp<CR>
nnoremap <leader>f  :bn<CR>
nnoremap <leader>g  :e#<CR>
nnoremap <silent> <leader>1  :1b<CR>
nnoremap <silent> <leader>2  :2b<CR>
nnoremap <silent> <leader>3  :3b<CR>
nnoremap <silent> <leader>4  :4b<CR>
nnoremap <silent> <leader>5  :5b<CR>
nnoremap <silent> <leader>6  :6b<CR>
nnoremap <silent> <leader>7  :7b<CR>
nnoremap <silent> <leader>8  :8b<CR>
nnoremap <silent> <leader>9  :9b<CR>

" ----------------------------------------------------------------------------
" Remove expandtab for Makefile and Python
"
au BufEnter [mM]akefile*,GNUmakefile,*.mk,*.mak,*.py set noexpandtab
au BufLeave [mM]akefile*,GNUmakefile,*.mk,*.mak,*.py set expandtab

" ----------------------------------------------------------------------------
" Use right movement keys!
"
nnoremap j  gj
nnoremap k  gk

" ----------------------------------------------------------------------------
" Emacs style keybindings in insert mode
"
inoremap <C-d> <C-o>x
inoremap <C-a> <C-o>I
inoremap <C-e> <C-o>A

" ----------------------------------------------------------------------------
" Move effectively among tabs
"
nnoremap <silent> <C-t>l :tabnext<CR>
nnoremap <silent> <C-t><Right> :tabnext<CR>
nnoremap <silent> <C-t>h :tabprevious<CR>
nnoremap <silent> <C-t><Left> :tabprevious<CR>
nnoremap <silent> <C-t>e :tabedit %<CR>
nnoremap <silent> <C-t>q :tabclose<CR>

" ----------------------------------------------------------------------------
" Move effectively among windows
"
nnoremap <C-w>h <C-w><C-h>
nnoremap <C-w>j <C-w><C-j>
nnoremap <C-w>k <C-w><C-k>
nnoremap <C-w>l <C-w><C-l>

" ----------------------------------------------------------------------------
" Underline
"
nnoremap <leader>u yypVr=

" ----------------------------------------------------------------------------
" Comments
"
autocmd FileType c,cpp,java,scala let b:cchar = '//'
autocmd FileType verilog          let b:cchar = '//'
autocmd FileType vhdl             let b:cchar = '--'
autocmd FileType sh,csh,tcsh      let b:cchar = '#'
autocmd FileType tcl,conf,fstab   let b:cchar = '#'
autocmd FileType make,muttrc,txt  let b:cchar = '#'
autocmd FileType remind,tmux      let b:cchar = '#'
autocmd FileType tex,sty          let b:cchar = '%'
autocmd FileType mail             let b:cchar = '>'
autocmd FileType vim              let b:cchar = '"'
autocmd FileType xdefaults        let b:cchar = '!'

function! CommentToggling() range
        if (match(getline('.'), '^\s*' . b:cchar) != -1)
                execute a:firstline . ',' . a:lastline . 's/^\(\s*\)' . escape(b:cchar, '/') . '/\1'
        else
                execute a:firstline . ',' . a:lastline . 's/^/' . escape(b:cchar, '/')
        endif
        nohlsearch
endfunction
noremap <silent> <leader>c :call CommentToggling()<CR>

" ----------------------------------------------------------------------------
" Ruler
"
function! Ruler()
        let l:tw = &textwidth ? &textwidth : 72
        let l:charNo = l:tw - strlen(b:cchar) - 1
        call append('.', b:cchar)
        exec "normal j"
        s/$/\=(' ' . repeat('-', l:charNo))
endfunction
nnoremap <leader>- :call Ruler()<CR>

" ----------------------------------------------------------------------------
" Do not remove indentation for comments when smartindex is set
"
inoremap # X#

" ----------------------------------------------------------------------------
" E-mails/notes
"
nnoremap <leader>s o[...]<Esc>j0
nnoremap <leader>ss o[....................snip....................]<Esc>j0
iab _h Hello
iab _br Best regards
iab _all All the best
iab _t Thanks in advance

" ----------------------------------------------------------------------------
" Common refuses
"
cnoremap Qa qa
cnoremap QA qa

" ----------------------------------------------------------------------------
" Toggle mouse paste mode with F12
"
nnoremap <silent> <F12> :set paste!<CR>
set pastetoggle=<F12>

" ----------------------------------------------------------------------------
" diff mode
"
set diffopt+=iwhite     " Ignore white speces
au FilterWritePre * if &diff | execute "nnoremap <C-p> [cz." | execute "nnoremap <C-n> ]cz." | endif

" ----------------------------------------------------------------------------
" Spell check when writing commit logs
"
autocmd filetype svn,*commit* setlocal spell spelllang=en

" ----------------------------------------------------------------------------
" Set completion to the current script (only if a specific plugin does
" not already exist for that filetype)
"
if has("autocmd") && exists("+omnifunc")
autocmd Filetype *
        \ if &omnifunc == "" |
        \       setlocal omnifunc=syntaxcomplete#Complete |
        \ endif
endif

" ----------------------------------------------------------------------------
" netrw config section
" (see http://ivanbrennan.nyc/blog/2014/01/16/rigging-vims-netrw)
"
let g:netrw_liststyle=3         " 0: thin view; 3: tree view
let g:netrw_banner=0            " No banner
let g:netrw_altv=1              " Open files shown on the right
let g:netrw_browse_split=4      " Open files in previous window
"let g:netrw_preview=1          " Preview window shown in a vertically split

function! VexToggle(dir)
        if exists("t:vex_buf_nr")
                call VexClose()
        else
                call VexOpen(a:dir)
        endif
endfunction

function! VexOpen(dir)
        let vex_width=50
        execute "Vexplore " . a:dir
        let t:vex_buf_nr=bufnr("%")
        wincmd H
        call VexSize(vex_width)
endfunction

function! VexClose()
        let curr_win_nr=winnr()
        let target_win_nr = (curr_win_nr == 1) ? winnr("#") : curr_win_nr
        1wincmd w
        close
        unlet t:vex_buf_nr
        execute (target_win_nr-1) . "wincmd w"
        call NormalizeWidths()
endfunction

function! VexSize(vex_width)
        execute "vertical resize" . a:vex_width
        set winfixwidth
        call NormalizeWidths()
endfunction

function! NormalizeWidths()
        let eadirection_backup=&eadirection
        set eadirection=hor
        set equalalways! equalalways!
        let &eadirection=eadirection_backup
        unlet eadirection_backup
endfunction

noremap <silent> <leader>, :call VexToggle(getcwd())<CR>
noremap <silent> <leader>. :call VexToggle("")<CR>

augroup NetrwGroup
        autocmd! BufEnter * call NormalizeWidths()
augroup END

" ----------------------------------------------------------------------------
" In mutt: 72-char per line max, set en spell checker
"
au BufRead ~/.mutt/tmp/mutt-* :source ~/.vim/mutt.vim

" ----------------------------------------------------------------------------
" For tmp files, map a killall keybind
"
au BufRead /tmp/* nnoremap <silent> <leader>k :1,$d<CR>ZZ

" ----------------------------------------------------------------------------
" Switch b/w spaces and tabs
"
nnoremap <silent> <leader><TAB> :set expandtab!<CR>:retab!<CR>
"au BufReadPost * retab! | silent earlier 1 | 0
"au BufWritePre * set noexpandtab | retab!
"au BufWritePost * set expandtab | retab!

" ----------------------------------------------------------------------------
" Save the contents of the current window " (<leader>v to restore)
"
au BufWinLeave * if expand("%") != "" | mkview | endif
nnoremap <silent> <leader>v :loadview<CR>
"au VimEnter * silent loadview

" ----------------------------------------------------------------------------
" Remove overheads for large files
"
" When file's dimension is > 100MB, set the following options:
" eventignore+=FileType (no syntax hilight etc, assumes FileType always on)
" noswapfile (save copy of file)
" bufhidden=unload (save memory when other file is viewed)
" buftype=nowritefile (is read-only)
" undolevels=-1 (no undo possible)
"
let g:LargeFile = 1024 * 1024 * 100
augroup LargeFile
        autocmd BufReadPre * let f=expand("<afile>") | if getfsize(f) > g:LargeFile | set eventignore+=FileType | setlocal noswapfile bufhidden=unload buftype=nowrite undolevels=-1 | else | set eventignore-=FileType | endif
augroup END

" ----------------------------------------------------------------------------
" Empty lines insertion
"
nnoremap <leader>o o<Esc>
nnoremap <leader>O O<Esc>
nnoremap <leader>n i<CR><Esc>
nnoremap <leader>\ i\<CR><Esc>^

" ----------------------------------------------------------------------------
" Move current line up/down
"
nnoremap <F2> :m +1<CR>
nnoremap <F3> :m -2<CR>

" ----------------------------------------------------------------------------
" Number incr/decr
"
nnoremap + <C-a>
nnoremap - <C-x>
vnoremap <silent> + :norm <CR>
vnoremap <silent> - :norm <CR>
vnoremap <leader>+ :II 1 ''<CR>
vnoremap <leader>- :II -1 ''<CR>

" ----------------------------------------------------------------------------
" Remove trailing spaces
"
function! RemoveTrailingSpaces()
        let _cpos = getpos(".")
        execute '%s/\s\+$//'
        execute 'nohlsearch'
        call setpos(".", _cpos)
endfunction
nnoremap <silent> <leader><Space> :call RemoveTrailingSpaces()<CR>

" ----------------------------------------------------------------------------
" Window zooming
"
function! ZoomWin()
        if exists('g:zoomOn') && g:zoomOn
                let g:zoomOn = 0
                tabclose
        else
                let g:zoomOn = 1
                tab split
        endif
endfunction
nnoremap <C-w><C-u> <C-w>o
nnoremap <silent> <C-w><C-o> :call ZoomWin()<CR>
nnoremap <silent> <C-w>o :call ZoomWin()<CR>

" ----------------------------------------------------------------------------
" Omni-completion function (when available)
"
inoremap @@ <C-x><C-o>

" ----------------------------------------------------------------------------
"  Edit a new file, whose name is under the cursor
"
map <leader>gf :e <cfile><CR>

" ----------------------------------------------------------------------------
"  Move cursor line to top/middle/bottom, scrolling the edit window when
"  the function is called with an argument (whatever it is), then clear
"  and redraw the screen
"
function! MoveCursorLine(...)
        let l:top    = line('w0')
        let l:bottom = line('w$')
        let l:center = (l:top + l:bottom) / 2
        if line('.') == l:center
                let l:cmd = a:0 ? "zt" : "H"
        elseif line('.') <= (l:top + &scrolloff)
                let l:cmd = a:0 ? "zb" : "L"
        else
                let l:cmd = a:0 ? "zz" : "M"
        endif
        execute "normal " . l:cmd
endfunction
cnoremap <silent> <C-l> :redraw!<CR>
nnoremap <silent> <C-l> :call MoveCursorLine("scroll")<CR>:redraw!<CR>
nnoremap <silent> <leader>m :call MoveCursorLine()<CR>:redraw!<CR>

" ----------------------------------------------------------------------------
" VCS helpers
"
function! VCScmd(...)
        let vcscmd  = a:1
        let vcsfile = a:2
        let dodiff  = (a:0 >= 3) ? a:3 : 0
        tab split
        leftabove vertical new
        setlocal nobuflisted buftype=nofile bufhidden=wipe noswapfile
        execute 'silent r !' . vcscmd . ' ' . vcsfile
        silent 1d
        setlocal nomodifiable
        if (dodiff == 1)
                windo diffthis
        endif
        normal <C-w>w
endfunction

function! VCSmaps()
        if isdirectory(expand('%:.:h') . '/' . 'CVS')
                nnoremap <buffer> <silent> <leader>vd :call VCScmd('cvs -q update -p', expand('%'), 1)<CR>
                nnoremap <buffer> <silent> <leader>vD :call VCScmd('cvs diff', expand('%'))<CR>
                nnoremap <buffer> <silent> <leader>vh :call VCScmd('cvs log', expand('%'))<CR>
        elseif isdirectory(expand('%:.:h') . '/' . '.SYNC')
                nnoremap <buffer> <silent> <leader>vd :call VCScmd('~/bin/dss-cat', expand('%'), 1)<CR>
                nnoremap <buffer> <silent> <leader>vD :call VCScmd('dssc diff -kk -unified -version Latest', expand('%'))<CR>
                nnoremap <buffer> <silent> <leader>vh :call VCScmd('dssc vhist', expand('%'))<CR>
        endif
endfunction

autocmd BufRead * call VCSmaps()

" ----------------------------------------------------------------------------
" Output the current syntax group
"
map <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
\ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
\ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" ----------------------------------------------------------------------------
" vim-notes plugin
"
let g:notes_directories=['$HOME/notes']
let g:notes_suffix=".txt"
let g:notes_unicode_enabled = 0
nnoremap <silent> <leader>nn :Note<CR>
nnoremap <silent> <leader>dn :DeleteNote!<CR>
vnoremap <silent> <leader>en :NoteFromSelectedText<CR>
vnoremap <silent> <leader>sn :SplitNoteFromSelectedText<CR>
vnoremap <silent> <leader>tn :TabNoteFromSelectedText<CR>
nnoremap <silent> <leader>wp :execute "Note Planning for WK".system("date --date=next-monday +%y%V")<CR>
nnoremap <silent> <leader>wt :r ~/notes/weekly_planning.tmpl<CR>

" ----------------------------------------------------------------------------
" Tabular plugin
"
nmap <silent> <leader>a= :Tabularize /=<CR>
vmap <silent> <leader>a= :Tabularize /=<CR>
nmap <silent> <leader>a: :Tabularize /:\zs<CR>
vmap <silent> <leader>a: :Tabularize /:\zs<CR>
nmap <silent> <leader>a<Bar> :Tabularize /\|/l1<CR>
vmap <silent> <leader>a<Bar> :Tabularize /\|/l1<CR>
nmap <silent> <leader>a<Space> :Tabularize / /l0<CR>
vmap <silent> <leader>a<Space> :Tabularize / /l0<CR>

" ----------------------------------------------------------------------------
" Tbone plugin
"
vnoremap <silent> <leader><CR> :Twrite Top<CR>
nnoremap <silent> <leader><CR> :.Twrite Top<CR>

" ----------------------------------------------------------------------------
" csv plugin
"
nnoremap <silent> <leader>A :%CSVArrangeColumn<CR>

" ----------------------------------------------------------------------------
" supertab plugin + completion popup menu adjustment
"
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabLongestHighlight = 1
let g:SuperTabMappingForward = "<F1>"
let g:SuperTabMappingBackward = "<S-F1>"
set completeopt=longest,menuone
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" ----------------------------------------------------------------------------
" ctrlp plugin
"
let g:ctrlp_map = '<leader>p'
let g:ctrlp_use_caching = 1
let g:ctrlp_clear_cache_on_exit = 0
let g:ctrlp_cache_dir = $HOME.'/.vim/cache/ctrlp'
let g:ctrlp_root_markers = ['.vim_ctrlp_root']
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_custom_ignore = '\v[\/](.git|.hg|.svn|CVS|.SYNC)$'

" ----------------------------------------------------------------------------
" vim-tmux-navigator plugin
"
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <Esc>[1;5A :TmuxNavigateUp<CR>
nnoremap <silent> <Esc>[1;5B :TmuxNavigateDown<CR>
nnoremap <silent> <Esc>[1;5C :TmuxNavigateRight<CR>
nnoremap <silent> <Esc>[1;5D :TmuxNavigateLeft<CR>
nnoremap <silent> <Esc>[A    :TmuxNavigateUp<CR>
nnoremap <silent> <Esc>[B    :TmuxNavigateDown<CR>
nnoremap <silent> <Esc>[C    :TmuxNavigateRight<CR>
nnoremap <silent> <Esc>[D    :TmuxNavigateLeft<CR>
nnoremap <silent> <C-\>      :TmuxNavigatePrevious<CR>

" ----------------------------------------------------------------------------
" Map <Tab> to <C-Tab> to allow inserting a tab character not at the beginning
" of the line (when g:SuperTabMappingForward is set to '<tab>')
"
inoremap <Esc>[27;5;9~ <Tab>

" ----------------------------------------------------------------------------
" Some useful abbreviations
"
cnoreabbrev f find
cnoreabbrev sf sfind
cnoreabbrev vsf vertical sfind

" ----------------------------------------------------------------------
" Source local vimrc file
"
try
        source ~/.vim/vimrc.local
catch
        " Do not output any error msg in case no local vimrc exists
endtry

